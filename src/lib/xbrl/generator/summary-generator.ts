/**
 * Summary iXBRL Generator (Debug Only)
 *
 * Generates a simplified label-value summary iXBRL document.
 * This is the LEGACY format kept for debugging purposes only.
 * The full MiCA-compliant document is generated by document-generator.ts.
 */

import type { XBRLContext, XBRLFact, XBRLUnit, IXBRLDocument } from '@/types/xbrl';
import type { WhitepaperData } from '@/types/whitepaper';
import { buildAllContexts } from './context-builder';
import { buildAllFacts, getRequiredUnits } from './fact-builder';

/**
 * XBRL Namespaces
 */
const NAMESPACES = {
  xbrli: 'http://www.xbrl.org/2003/instance',
  ix: 'http://www.xbrl.org/2013/inlineXBRL',
  ixt: 'http://www.xbrl.org/inlineXBRL/transformation/2020-02-12',
  link: 'http://www.xbrl.org/2003/linkbase',
  xlink: 'http://www.w3.org/1999/xlink',
  mica: 'https://www.esma.europa.eu/taxonomy/2025-03-31/mica',
  iso4217: 'http://www.xbrl.org/2003/iso4217',
};

/**
 * Taxonomy reference URL
 */
const TAXONOMY_REF = 'https://www.esma.europa.eu/taxonomy/2025-03-31/mica/mica-2025-03-31.xsd';

/**
 * Escape HTML special characters
 */
function escapeHtml(text: string): string {
  return text
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

/**
 * Generate XML for a context
 */
function renderContext(context: XBRLContext): string {
  let periodXml: string;

  if ('instant' in context.period) {
    periodXml = `<xbrli:instant>${context.period.instant}</xbrli:instant>`;
  } else {
    periodXml = `
        <xbrli:startDate>${context.period.startDate}</xbrli:startDate>
        <xbrli:endDate>${context.period.endDate}</xbrli:endDate>`;
  }

  let scenarioXml = '';
  if (context.scenario) {
    if (context.scenario.explicitMember) {
      scenarioXml = `
      <xbrli:scenario>
        <xbrldi:explicitMember dimension="${context.scenario.explicitMember.dimension}">${context.scenario.explicitMember.value}</xbrldi:explicitMember>
      </xbrli:scenario>`;
    } else if (context.scenario.typedMember) {
      scenarioXml = `
      <xbrli:scenario>
        <xbrldi:typedMember dimension="${context.scenario.typedMember.dimension}">
          <mica:value>${escapeHtml(context.scenario.typedMember.value)}</mica:value>
        </xbrldi:typedMember>
      </xbrli:scenario>`;
    }
  }

  return `
    <xbrli:context id="${context.id}">
      <xbrli:entity>
        <xbrli:identifier scheme="${context.entity.scheme}">${context.entity.identifier}</xbrli:identifier>
      </xbrli:entity>
      <xbrli:period>${periodXml}
      </xbrli:period>${scenarioXml}
    </xbrli:context>`;
}

/**
 * Generate XML for a unit
 */
function renderUnit(unit: XBRLUnit): string {
  return `
    <xbrli:unit id="${unit.id}">
      <xbrli:measure>${unit.measure}</xbrli:measure>
    </xbrli:unit>`;
}

/**
 * Render a fact as Inline XBRL element
 */
function renderFact(fact: XBRLFact): string {
  const idAttr = fact.id ? ` id="${fact.id}"` : '';
  const unitAttr = fact.unitRef ? ` unitRef="${fact.unitRef}"` : '';
  const decimalsAttr = fact.decimals !== undefined ? ` decimals="${fact.decimals}"` : '';
  const escapeAttr = fact.escape !== undefined ? ` escape="${fact.escape}"` : '';

  // Determine if it's a numeric or non-numeric fact
  const isNumeric = fact.unitRef !== undefined;

  if (isNumeric) {
    // Use ix:nonFraction for numeric values
    return `<ix:nonFraction${idAttr} name="${fact.name}" contextRef="${fact.contextRef}"${unitAttr}${decimalsAttr} format="ixt:num-dot-decimal">${fact.value}</ix:nonFraction>`;
  } else {
    // Use ix:nonNumeric for text values
    const value = fact.escape ? escapeHtml(String(fact.value)) : String(fact.value);
    return `<ix:nonNumeric${idAttr} name="${fact.name}" contextRef="${fact.contextRef}"${escapeAttr}>${value}</ix:nonNumeric>`;
  }
}

/**
 * Generate the complete iXBRL document
 */
export function generateSummaryIXBRLDocument(data: Partial<WhitepaperData>): string {
  // Build contexts
  const contexts = buildAllContexts(data);

  // Build facts
  const facts = buildAllFacts(data);

  // Get required units
  const units = getRequiredUnits(facts);

  // Render hidden XBRL header block
  const contextsXml = contexts.map(renderContext).join('\n');
  const unitsXml = units.map(renderUnit).join('\n');

  // Group facts by section for readable output
  const factsBySection = groupFactsBySection(facts);

  // Generate namespace declarations
  const nsDeclarations = Object.entries(NAMESPACES)
    .map(([prefix, uri]) => `xmlns:${prefix}="${uri}"`)
    .join('\n    ');

  // Build the document
  const document = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
    xmlns:xbrldi="http://xbrl.org/2006/xbrldi"
    ${nsDeclarations}
    lang="${data.language || 'en'}">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MiCA Crypto-Asset White Paper - ${escapeHtml(data.partD?.cryptoAssetName || 'Unknown')}</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 2rem;
      color: #1a1a1a;
    }
    h1, h2, h3 { color: #003366; }
    .ix-hidden { display: none; }
    .section { margin-bottom: 2rem; }
    .field { margin-bottom: 1rem; }
    .field-label { font-weight: 600; color: #666; }
    .field-value { margin-left: 0.5rem; }
    table { width: 100%; border-collapse: collapse; margin: 1rem 0; }
    th, td { border: 1px solid #ddd; padding: 0.75rem; text-align: left; }
    th { background: #f5f5f5; }
    .disclaimer { background: #fff3cd; padding: 1rem; border-radius: 4px; margin: 1rem 0; }
  </style>
</head>
<body>
  <!-- Hidden XBRL Header Block -->
  <div class="ix-hidden">
    <ix:header>
      <ix:references>
        <link:schemaRef xlink:type="simple" xlink:href="${TAXONOMY_REF}" />
      </ix:references>
      <ix:resources>
        ${contextsXml}
        ${unitsXml}
      </ix:resources>
    </ix:header>
  </div>

  <!-- Document Content -->
  <header>
    <h1>Crypto-Asset White Paper</h1>
    <p>Pursuant to Regulation (EU) 2023/1114 (MiCA)</p>
  </header>

  <div class="disclaimer">
    <strong>Important Notice:</strong> This crypto-asset white paper has not been approved by any competent authority in any Member State of the European Union. The offeror of the crypto-asset is solely responsible for the content of this crypto-asset white paper.
  </div>

  ${renderSection('Part A: Information about the Offeror', factsBySection.partA || [])}
  ${renderSection('Part D: Information about the Crypto-Asset', factsBySection.partD || [])}
  ${renderSection('Part E: Information about the Offer to the Public', factsBySection.partE || [])}
  ${renderSection('Part H: Information on the Underlying Technology', factsBySection.partH || [])}
  ${renderSection('Part J: Information on Sustainability', factsBySection.partJ || [])}

  <footer>
    <p><small>Document generated on ${data.documentDate || new Date().toISOString().split('T')[0]}</small></p>
  </footer>
</body>
</html>`;

  return document;
}

/**
 * Sections grouping type
 */
interface FactSections {
  partA: XBRLFact[];
  partD: XBRLFact[];
  partE: XBRLFact[];
  partH: XBRLFact[];
  partJ: XBRLFact[];
  other: XBRLFact[];
}

/**
 * Group facts by their section (Part A, D, E, etc.)
 */
function groupFactsBySection(facts: XBRLFact[]): FactSections {
  const sections: FactSections = {
    partA: [],
    partD: [],
    partE: [],
    partH: [],
    partJ: [],
    other: [],
  };

  for (const fact of facts) {
    if (fact.name.includes('Offeror') || fact.name.includes('PartA')) {
      sections.partA.push(fact);
    } else if (fact.name.includes('CryptoAsset') || fact.name.includes('Token') || fact.name.includes('Blockchain') || fact.name.includes('Project')) {
      sections.partD.push(fact);
    } else if (fact.name.includes('Offering') || fact.name.includes('Price') || fact.name.includes('Subscription') || fact.name.includes('Withdrawal')) {
      sections.partE.push(fact);
    } else if (fact.name.includes('Technology') || fact.name.includes('SmartContract')) {
      sections.partH.push(fact);
    } else if (fact.name.includes('Energy') || fact.name.includes('Sustainability') || fact.name.includes('Renewable')) {
      sections.partJ.push(fact);
    } else {
      sections.other.push(fact);
    }
  }

  return sections;
}

/**
 * Render a section with its facts
 */
function renderSection(title: string, facts: XBRLFact[]): string {
  if (facts.length === 0) {
    return '';
  }

  const fieldsHtml = facts.map((fact) => {
    const label = formatLabel(fact.name);
    return `
    <div class="field">
      <span class="field-label">${label}:</span>
      <span class="field-value">${renderFact(fact)}</span>
    </div>`;
  }).join('\n');

  return `
  <section class="section">
    <h2>${title}</h2>
    ${fieldsHtml}
  </section>`;
}

/**
 * Format element name to readable label
 */
function formatLabel(name: string): string {
  // Remove namespace prefix
  const localName = name.split(':')[1] || name;

  // Add spaces before capitals and format
  return localName
    .replace(/([A-Z])/g, ' $1')
    .replace(/^\\s/, '')
    .trim();
}

/**
 * Create an IXBRLDocument object (for programmatic use)
 */
export function createSummaryIXBRLDocument(data: Partial<WhitepaperData>): IXBRLDocument {
  const contexts = buildAllContexts(data);
  const facts = buildAllFacts(data);
  const units = getRequiredUnits(facts);

  return {
    contexts,
    units,
    facts,
    language: data.language || 'en',
    taxonomyRef: TAXONOMY_REF,
  };
}
